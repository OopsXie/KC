// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.20.3
// source: metaServer.proto

// 与 dataServer.proto 使用同一个包名，便于管理

package pb

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MetaServerService_CreateNode_FullMethodName         = "/dfs_project.MetaServerService/CreateNode"
	MetaServerService_GetNodeInfo_FullMethodName        = "/dfs_project.MetaServerService/GetNodeInfo"
	MetaServerService_ListDirectory_FullMethodName      = "/dfs_project.MetaServerService/ListDirectory"
	MetaServerService_DeleteNode_FullMethodName         = "/dfs_project.MetaServerService/DeleteNode"
	MetaServerService_GetBlockLocations_FullMethodName  = "/dfs_project.MetaServerService/GetBlockLocations"
	MetaServerService_FinalizeWrite_FullMethodName      = "/dfs_project.MetaServerService/FinalizeWrite"
	MetaServerService_GetClusterInfo_FullMethodName     = "/dfs_project.MetaServerService/GetClusterInfo"
	MetaServerService_GetReplicationInfo_FullMethodName = "/dfs_project.MetaServerService/GetReplicationInfo"
	MetaServerService_Heartbeat_FullMethodName          = "/dfs_project.MetaServerService/Heartbeat"
	MetaServerService_SyncWAL_FullMethodName            = "/dfs_project.MetaServerService/SyncWAL"
	MetaServerService_GetLeader_FullMethodName          = "/dfs_project.MetaServerService/GetLeader"
)

// MetaServerServiceClient is the client API for MetaServerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MetaServerService 定义了元数据服务器需要暴露的所有 gRPC 接口
type MetaServerServiceClient interface {
	// 对应考核点 A1: 创建文件或目录
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// 对应考核点 A2: 获取单个文件或目录的属性信息
	GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error)
	// 对应考核点 A2: 列出目录下的所有条目
	ListDirectory(ctx context.Context, in *ListDirectoryRequest, opts ...grpc.CallOption) (*ListDirectoryResponse, error)
	// 对应考核点 A3: 删除文件或目录 (支持递归)
	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// 对应考核点 A4: 为写入/读取文件做准备，获取数据块的位置信息
	GetBlockLocations(ctx context.Context, in *GetBlockLocationsRequest, opts ...grpc.CallOption) (*GetBlockLocationsResponse, error)
	// 对应考核点 A4: 当 Client 写完一个文件后，调用此接口来最终确认
	FinalizeWrite(ctx context.Context, in *FinalizeWriteRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// 对应考核点 A5, A6, B7: 获取集群信息，用于展示副本分布等
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	// 获取文件的副本分布情况
	GetReplicationInfo(ctx context.Context, in *GetReplicationInfoRequest, opts ...grpc.CallOption) (*GetReplicationInfoResponse, error)
	// 接收来自 DataServer 的心跳和块报告
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// 用于主从节点之间，实时同步元数据操作日志 (WAL)
	SyncWAL(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[LogEntry, SimpleResponse], error)
	// 获取主从信息 (HA 支持)
	GetLeader(ctx context.Context, in *GetLeaderRequest, opts ...grpc.CallOption) (*GetLeaderResponse, error)
}

type metaServerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMetaServerServiceClient(cc grpc.ClientConnInterface) MetaServerServiceClient {
	return &metaServerServiceClient{cc}
}

func (c *metaServerServiceClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, MetaServerService_CreateNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeInfoResponse)
	err := c.cc.Invoke(ctx, MetaServerService_GetNodeInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) ListDirectory(ctx context.Context, in *ListDirectoryRequest, opts ...grpc.CallOption) (*ListDirectoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDirectoryResponse)
	err := c.cc.Invoke(ctx, MetaServerService_ListDirectory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, MetaServerService_DeleteNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) GetBlockLocations(ctx context.Context, in *GetBlockLocationsRequest, opts ...grpc.CallOption) (*GetBlockLocationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlockLocationsResponse)
	err := c.cc.Invoke(ctx, MetaServerService_GetBlockLocations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) FinalizeWrite(ctx context.Context, in *FinalizeWriteRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SimpleResponse)
	err := c.cc.Invoke(ctx, MetaServerService_FinalizeWrite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, MetaServerService_GetClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) GetReplicationInfo(ctx context.Context, in *GetReplicationInfoRequest, opts ...grpc.CallOption) (*GetReplicationInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReplicationInfoResponse)
	err := c.cc.Invoke(ctx, MetaServerService_GetReplicationInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, MetaServerService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServerServiceClient) SyncWAL(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[LogEntry, SimpleResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MetaServerService_ServiceDesc.Streams[0], MetaServerService_SyncWAL_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LogEntry, SimpleResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MetaServerService_SyncWALClient = grpc.ClientStreamingClient[LogEntry, SimpleResponse]

func (c *metaServerServiceClient) GetLeader(ctx context.Context, in *GetLeaderRequest, opts ...grpc.CallOption) (*GetLeaderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLeaderResponse)
	err := c.cc.Invoke(ctx, MetaServerService_GetLeader_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetaServerServiceServer is the server API for MetaServerService service.
// All implementations must embed UnimplementedMetaServerServiceServer
// for forward compatibility.
//
// MetaServerService 定义了元数据服务器需要暴露的所有 gRPC 接口
type MetaServerServiceServer interface {
	// 对应考核点 A1: 创建文件或目录
	CreateNode(context.Context, *CreateNodeRequest) (*SimpleResponse, error)
	// 对应考核点 A2: 获取单个文件或目录的属性信息
	GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error)
	// 对应考核点 A2: 列出目录下的所有条目
	ListDirectory(context.Context, *ListDirectoryRequest) (*ListDirectoryResponse, error)
	// 对应考核点 A3: 删除文件或目录 (支持递归)
	DeleteNode(context.Context, *DeleteNodeRequest) (*SimpleResponse, error)
	// 对应考核点 A4: 为写入/读取文件做准备，获取数据块的位置信息
	GetBlockLocations(context.Context, *GetBlockLocationsRequest) (*GetBlockLocationsResponse, error)
	// 对应考核点 A4: 当 Client 写完一个文件后，调用此接口来最终确认
	FinalizeWrite(context.Context, *FinalizeWriteRequest) (*SimpleResponse, error)
	// 对应考核点 A5, A6, B7: 获取集群信息，用于展示副本分布等
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	// 获取文件的副本分布情况
	GetReplicationInfo(context.Context, *GetReplicationInfoRequest) (*GetReplicationInfoResponse, error)
	// 接收来自 DataServer 的心跳和块报告
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// 用于主从节点之间，实时同步元数据操作日志 (WAL)
	SyncWAL(grpc.ClientStreamingServer[LogEntry, SimpleResponse]) error
	// 获取主从信息 (HA 支持)
	GetLeader(context.Context, *GetLeaderRequest) (*GetLeaderResponse, error)
	mustEmbedUnimplementedMetaServerServiceServer()
}

// UnimplementedMetaServerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMetaServerServiceServer struct{}

func (UnimplementedMetaServerServiceServer) CreateNode(context.Context, *CreateNodeRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNode not implemented")
}
func (UnimplementedMetaServerServiceServer) GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedMetaServerServiceServer) ListDirectory(context.Context, *ListDirectoryRequest) (*ListDirectoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDirectory not implemented")
}
func (UnimplementedMetaServerServiceServer) DeleteNode(context.Context, *DeleteNodeRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (UnimplementedMetaServerServiceServer) GetBlockLocations(context.Context, *GetBlockLocationsRequest) (*GetBlockLocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockLocations not implemented")
}
func (UnimplementedMetaServerServiceServer) FinalizeWrite(context.Context, *FinalizeWriteRequest) (*SimpleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinalizeWrite not implemented")
}
func (UnimplementedMetaServerServiceServer) GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedMetaServerServiceServer) GetReplicationInfo(context.Context, *GetReplicationInfoRequest) (*GetReplicationInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReplicationInfo not implemented")
}
func (UnimplementedMetaServerServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedMetaServerServiceServer) SyncWAL(grpc.ClientStreamingServer[LogEntry, SimpleResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SyncWAL not implemented")
}
func (UnimplementedMetaServerServiceServer) GetLeader(context.Context, *GetLeaderRequest) (*GetLeaderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLeader not implemented")
}
func (UnimplementedMetaServerServiceServer) mustEmbedUnimplementedMetaServerServiceServer() {}
func (UnimplementedMetaServerServiceServer) testEmbeddedByValue()                           {}

// UnsafeMetaServerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetaServerServiceServer will
// result in compilation errors.
type UnsafeMetaServerServiceServer interface {
	mustEmbedUnimplementedMetaServerServiceServer()
}

func RegisterMetaServerServiceServer(s grpc.ServiceRegistrar, srv MetaServerServiceServer) {
	// If the following call pancis, it indicates UnimplementedMetaServerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MetaServerService_ServiceDesc, srv)
}

func _MetaServerService_CreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).CreateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_CreateNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).CreateNode(ctx, req.(*CreateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_GetNodeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).GetNodeInfo(ctx, req.(*GetNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_ListDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).ListDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_ListDirectory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).ListDirectory(ctx, req.(*ListDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_DeleteNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).DeleteNode(ctx, req.(*DeleteNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_GetBlockLocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockLocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).GetBlockLocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_GetBlockLocations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).GetBlockLocations(ctx, req.(*GetBlockLocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_FinalizeWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinalizeWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).FinalizeWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_FinalizeWrite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).FinalizeWrite(ctx, req.(*FinalizeWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_GetClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_GetReplicationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReplicationInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).GetReplicationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_GetReplicationInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).GetReplicationInfo(ctx, req.(*GetReplicationInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaServerService_SyncWAL_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MetaServerServiceServer).SyncWAL(&grpc.GenericServerStream[LogEntry, SimpleResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MetaServerService_SyncWALServer = grpc.ClientStreamingServer[LogEntry, SimpleResponse]

func _MetaServerService_GetLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServerServiceServer).GetLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetaServerService_GetLeader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServerServiceServer).GetLeader(ctx, req.(*GetLeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MetaServerService_ServiceDesc is the grpc.ServiceDesc for MetaServerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MetaServerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dfs_project.MetaServerService",
	HandlerType: (*MetaServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNode",
			Handler:    _MetaServerService_CreateNode_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _MetaServerService_GetNodeInfo_Handler,
		},
		{
			MethodName: "ListDirectory",
			Handler:    _MetaServerService_ListDirectory_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _MetaServerService_DeleteNode_Handler,
		},
		{
			MethodName: "GetBlockLocations",
			Handler:    _MetaServerService_GetBlockLocations_Handler,
		},
		{
			MethodName: "FinalizeWrite",
			Handler:    _MetaServerService_FinalizeWrite_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _MetaServerService_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetReplicationInfo",
			Handler:    _MetaServerService_GetReplicationInfo_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _MetaServerService_Heartbeat_Handler,
		},
		{
			MethodName: "GetLeader",
			Handler:    _MetaServerService_GetLeader_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SyncWAL",
			Handler:       _MetaServerService_SyncWAL_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "metaServer.proto",
}
