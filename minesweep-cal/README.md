# Minesweep-Cal 扫雷雷数计算器

本项目是一个使用 Go 编写的扫雷局面分析器，用于计算一个已知局面中可能存在的最小和最大地雷数量。

## 项目功能

- 检查输入棋盘的格式和逻辑合法性
- 使用约束满足模型（CSP）建立线索与未知格子的关系
- 自动识别并分离多个连通子问题，提升求解效率
- 使用回溯搜索求解最大与最小地雷数
- 支持单元测试，涵盖正常与错误样例

## 项目结构
```
minesweep-cal/
├── main.go // 主程序与计算逻辑
├── main_test.go // 单元测试用例
├── go.mod // Go 模块文件
└── README.md // 项目说明文档
```

## 使用说明
### 编译并运行

```bash
go run main.go
```

程序将运行默认棋盘示例并输出如下信息：
```
maxMinesNum: 147
minMinesNum: 15
useTime: 512μs
```

### 执行单元测试

```bash
go test -v
```

## calculate 函数
```
func calculate(minesweeper [][]int) (int, int){
    // 计算最小和最大地雷数
    // 返回值：maxMines, minMines
    // 错误或无解将返回 -1
    // return -1, -1
}
```

## 算法解析

本程序解决扫雷问题的核心算法可以分解为以下几个步骤：

1.  **预处理 (Preprocessing)**
    * 程序首先遍历棋盘，识别出所有的数字线索格以及与这些线索直接相邻的未打开格（定义为**相关未知格**）。
    * 不与任何数字线索相邻的未打开格被归类为**孤立未知格**，其数量将被单独统计。
    * 每一个数字线索格与其周围的相关未知格共同构成一个**约束条件**。例如，一个值为 `2` 的线索格和它周围的3个相关未知格意味着这3个格子中必须且只能存在2个地雷。

2.  **分治策略 (Divide and Conquer)**
    * 在复杂的棋盘中，不同区域的约束往往是相互独立的。
    * 程序将所有相关未知格视为图的节点，如果两个未知格属于同一个约束条件，则它们之间存在一条边。通过图论的**广度优先搜索 (BFS)** 或**深度优先搜索 (DFS)**，可以将图分解为多个**连通分量**。
    * 每个连通分量代表一个独立的子问题，可以被分开求解，从而避免了对整个棋盘进行组合爆炸式的搜索。

3.  **回溯搜索 (Backtracking)**
    * 对于每个独立的连通分量（子问题），程序采用回溯算法来探索所有可能的地雷布局。
    * 该算法会递归地为子问题中的每一个相关未知格尝试两种状态：**是地雷 (1)** 或 **不是地雷 (0)**。
    * **剪枝优化 (Pruning)** 是此步骤的关键。在递归的任何一步，如果一个部分布局已经导致某个约束条件被违反（例如，一个标记为 `1` 的线索格周围已经尝试放置了2个地雷），则立即终止该搜索分支，不再进行更深层次的递归。这极大地提高了搜索效率。

4.  **结果汇总 (Aggregation)**
    * 每个子问题求解完毕后，会返回该区域内可能的最小和最大地雷数。
    * 主程序将所有子问题的结果进行累加，得到整个棋盘所有**相关未知格**区域的总`minMines`和`maxMines`。
    * 最终，全局的最小雷数即为`minMines`。全局的最大雷数则为 `maxMines` 与所有**孤立未知格**数量之和（因为孤立格可以是任意数量的地雷，对最大值贡献最大）。
